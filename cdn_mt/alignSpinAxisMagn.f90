!--------------------------------------------------------------------------------
! Copyright (c) 2018 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and avhttps://gcc.gnu.org/onlinedocs/gfortran/SQRT.htmlailable as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!------------------------------------------------------------------------------
!  This routine allows to rotate the cdn in a way that the direction of magnetization aligns with the direction of the spin quantization axis.
!  This routine also allows to reverse the rotation by using the angles stored in atoms (nococonv%alph,nococonv%beta) which are generated by the
!  routine magnMomFromDen.
!
! Robin Hilgers, Nov  '19 Adaption to new Nococonv type in Feb '20, Added RelaxMixing parameters Jul '20'
MODULE m_alignSpinAxisMagn



USE m_magnMomFromDen
USE m_types
USE m_types_fleurinput
USE m_flipcdn
USE m_constants
USE m_polangle


IMPLICIT NONE

CONTAINS
SUBROUTINE rotateMagnetToSpinAxis(vacuum,sphhar,stars&
,sym,oneD,cell,noco,nococonv,input,atoms,den,l_firstIt)
   TYPE(t_input), INTENT(IN)     :: input
   TYPE(t_atoms), INTENT(IN)     :: atoms
   TYPE(t_noco), INTENT(IN)      :: noco
   TYPE(t_nococonv),INTENT(INOUT):: nococonv
   TYPE(t_stars),INTENT(IN)      :: stars
   TYPE(t_vacuum),INTENT(IN)     :: vacuum
   TYPE(t_sphhar),INTENT(IN)     :: sphhar
   TYPE(t_sym),INTENT(IN)        :: sym
   TYPE(t_oneD),INTENT(IN)       :: oneD
   TYPE(t_cell),INTENT(IN)       :: cell
   TYPE(t_potden), INTENT(INOUT) :: den

   TYPE(t_potden)                :: denTemp
   LOGICAL                       :: l_firstIt,nonZeroAngles !Switch which is handed in by function calls which determines if we have to rotate cdn initially.
   REAL                          :: moments(3,atoms%ntype)
   REAL                          :: phiTemp(atoms%ntype),thetaTemp(atoms%ntype)
   REAL                          :: diffT(atoms%ntype),diffP(atoms%ntype),eps, zeros(atoms%ntype)
   INTEGER                       :: ierr(2)
   INTEGER                       :: i
   eps=0.0001
   zeros(:)=0.0
   nonZeroAngles=.FALSE.
   DO i=1, atoms%ntype
     IF(noco%alph_inp(i).NE.0.0) nonZeroAngles=.TRUE.
     IF(noco%beta_inp(i).NE.0.0) nonZeroAngles=.TRUE.
   END DO
   
   IF(l_firstIt.AND.nonZeroAngles) THEN
! Rotates cdn by given noco angles in first iteration. WARNING: If you want to continue/restart a calculation with MT relaxation set noco angles to 0!
     CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,zeros,noco%beta_inp,den)
     CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,noco%alph_inp,zeros,den)
     !Setting angles to zero since we want our spinQ Axis to remain the same when writing out the density.
     nococonv%alph=zeros
     nococonv%beta=zeros
   END IF
! Get magnetization direction
   IF(noco%mix_RelaxWeightOffD.NE.1.0) THEN
      CALL denTemp%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_DEN)
      denTemp%mt(:,:,:,:)=den%mt(:,:,:,:)
      denTemp%mt(:,:,:,3:4)=denTemp%mt(:,:,:,3:4)*noco%mix_RelaxWeightOffD
      CALL magnMomFromDen(input,atoms,noco,denTemp,moments,thetaTemp,phiTemp)
   ELSE
      CALL magnMomFromDen(input,atoms,noco,den,moments,thetaTemp,phiTemp)
   END IF
   phiTemp(:)=(-1)*phiTemp(:)
   !Calculate angular rotation which has to be done.
   diffT=thetaTemp-nococonv%beta
   diffP=phiTemp-nococonv%alph

   DO i=1, atoms%ntype
! Set angles to zero if too low. (Prevent numerical rubbish to appear)
      IF (abs(diffT(i)).LE.eps) diffT(i)=0.0
      IF (abs(diffP(i)).LE.eps) diffP(i)=0.0
   END DO

!Which angles to keep constant from input den
   IF (.NOT.noco%l_RelaxAlpha) THEN  
      IF(l_firstIT) THEN 
         nococonv%alphRlx=diffP
         CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,-diffP,zeros,den)
      END IF
   END IF


! Rotate cdn by direction of magnetization so it alings with spin quantization axis.
   IF (noco%l_RelaxAlpha.OR..NOT.l_firstIT) CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,-diffP,zeros,den)
!Which angles to keep constant from input den
   IF (.NOT.noco%l_RelaxBeta) THEN
      IF(l_firstIT) THEN 
         nococonv%betaRlx=diffT
         CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,zeros,-diffT,den)
         END IF
   END IF


   IF (noco%l_RelaxBeta.OR..NOT.l_firstIT) CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,zeros,-diffT,den)
!Store angles in nococonv
    IF (noco%l_RelaxBeta) nococonv%beta=nococonv%beta+diffT
    IF (.NOT.noco%l_RelaxBeta)  nococonv%beta=nococonv%betaRlx
    IF (noco%l_RelaxAlpha) nococonv%alph=nococonv%alph+diffP
    IF(.NOT.noco%l_RelaxAlpha) nococonv%alph=nococonv%alphRlx
! Set angles to zero if too low. (Prevent numerical rubbish to appear)
   DO i=1, atoms%ntype
      IF (abs(nococonv%beta(i)).LE.eps) nococonv%beta(i)=0.0
      IF (abs(nococonv%alph(i)).LE.eps) nococonv%alph(i)=0.0
   END DO


END SUBROUTINE rotateMagnetToSpinAxis


SUBROUTINE rotateMagnetFromSpinAxis(noco,nococonv,vacuum,sphhar,stars&
,sym,oneD,cell,input,atoms,inDen, den)
   TYPE(t_input), INTENT(IN)             :: input
   TYPE(t_atoms), INTENT(IN)             :: atoms
   TYPE(t_noco), INTENT(IN)              :: noco
   TYPE(t_nococonv), INTENT(INOUT)       :: nococonv
   TYPE(t_stars),INTENT(IN)              :: stars
   TYPE(t_vacuum),INTENT(IN)             :: vacuum
   TYPE(t_sphhar),INTENT(IN)             :: sphhar
   TYPE(t_sym),INTENT(IN)                :: sym
   TYPE(t_oneD),INTENT(IN)               :: oneD
   TYPE(t_cell),INTENT(IN)               :: cell
   TYPE(t_potden), INTENT(INOUT)         :: inDen
   TYPE(t_potden), OPTIONAL,INTENT(INOUT):: den

   INTEGER                               :: i
   REAL                                  :: phiTemp(atoms%ntype),thetaTemp(atoms%ntype), zeros(atoms%ntype)
   REAL                                  :: moments(3,atoms%ntype)
   INTEGER                               :: ierr(2)

   zeros(:)=0.0
! Backwards rotation so SQA and magnetization don't align anymore. This is needed since you otherwise run into issues in the mixing since you mix cdn's which have been rotated
! in different directions.
   CAlL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,zeros,nococonv%beta,inDen)
   CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,nococonv%alph,zeros,inDen)
   IF (present(den)) THEN
      CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,zeros,nococonv%beta,den)
      CALL flipcdn(atoms,input,vacuum,sphhar,stars,sym,noco,oneD,cell,nococonv%alph,zeros,den)
   END IF
! Nococonv is zero now since rotation has been reverted.
      nococonv%alph=zeros
      nococonv%beta=zeros


END SUBROUTINE rotateMagnetFromSpinAxis


END MODULE m_alignSpinAxisMagn
