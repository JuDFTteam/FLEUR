!--------------------------------------------------------------------------------
! Copyright (c) 2021 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and available as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!--------------------------------------------------------------------------------
MODULE m_dfpt
    USE m_juDFT_time
    USE m_constants
    USE m_types
    USE m_dfpt_check
    USE m_dfpt_test
    USE m_dfpt_init
    USE m_dfpt_sternheimer
    USE m_dfpt_dynmat
    use m_jpSternheimer,     only : solveSternheimerSCC
    use m_jp2ndOrdQuant,     only : CalcIIEnerg2
    use m_jpSetupDynMat,     only : SetupDynamicMatrix
    use m_jpProcessDynMat!,   only : DiagonalizeDynMat, CalculateFrequencies

    IMPLICIT NONE

CONTAINS
    SUBROUTINE dfpt(juPhon, sym, input, atoms, sphhar, stars, cell, noco, nococonv, &
                  & kpts, qpts, fmpi, results, enpara, rho, vTot, vCoul, vxc, exc, eig_id, nvfull, GbasVec_eig)

        TYPE(t_juPhon),   INTENT(IN)  :: juPhon
        TYPE(t_sym),      INTENT(IN)  :: sym
        TYPE(t_input),    INTENT(IN)  :: input
        TYPE(t_atoms),    INTENT(IN)  :: atoms
        TYPE(t_sphhar),   INTENT(IN)  :: sphhar
        TYPE(t_stars),    INTENT(IN)  :: stars
        TYPE(t_cell),     INTENT(IN)  :: cell
        TYPE(t_noco),     INTENT(IN)  :: noco
        TYPE(t_nococonv), INTENT(IN)  :: nococonv
        TYPE(t_kpts),     INTENT(IN)  :: kpts
        TYPE(t_kpts),     INTENT(IN)  :: qpts
        TYPE(t_mpi),      INTENT(IN)  :: fmpi
        TYPE(t_results),  INTENT(IN)  :: results
        TYPE(t_enpara),   INTENT(IN)  :: enpara
        TYPE(t_potden),   INTENT(IN)  :: rho, vTot, vCoul, vxc, exc
        INTEGER,          INTENT(IN)  :: eig_id
        INTEGER,          INTENT(IN)  :: nvfull(:, :), GbasVec_eig(:, :, :, :)

        TYPE(t_usdus)                 :: usdus
        TYPE(t_potden)                :: vTotclean
        TYPE(t_jpPotden)              :: rho0, grRho0, vTot0, grVTot0
        type(t_tlmplm)                :: tdHS0
        COMPLEX, ALLOCATABLE          :: loosetdout(:, :, :, :)

        REAL,             ALLOCATABLE :: El(:, :, :, :)
        INTEGER,          ALLOCATABLE :: recG(:, :), GbasVec(:, :), ilst(:, :, :)
        INTEGER                       :: ngdp2km
        INTEGER,          ALLOCATABLE :: gdp2Ind(:, :, :)
        INTEGER                       :: gdp2iLim(2, 3)
        INTEGER,          ALLOCATABLE :: nRadFun(:, :), iloTable(:, :, :), ilo2p(:, :)
        REAL,             ALLOCATABLE :: uuilon(:, :)
        REAL,             ALLOCATABLE :: duilon(:, :)
        REAL,             ALLOCATABLE :: ulouilopn(:, :, :)
        INTEGER,          ALLOCATABLE :: kveclo(:,:)
        REAL,             ALLOCATABLE :: rbas1(:, :, :, :, :)
        REAL,             ALLOCATABLE :: rbas2(:, :, :, :, :)
        REAL,             ALLOCATABLE :: gridf(:, :)
        COMPLEX,          ALLOCATABLE :: z0(:, :, :, :)
        complex,           allocatable :: grVxcIRKern(:)
        real,              allocatable :: dKernMTGPts(:, :, :)
        real,              allocatable :: gausWts(:)
        complex,           allocatable :: ylm(:, :)
        complex,           allocatable :: qpwcG(:, :)
        complex,           allocatable :: rho1MTCoreDispAt(:, :, :, :)
        complex,           allocatable :: grVeff0MT_init(:, :, :, :)
        complex,           allocatable :: grVeff0MT_main(:, :, :, :)
        complex,           allocatable :: grVext0IR_DM(:, :)
        complex,           allocatable :: grVext0MT_DM(:, :, :, :)
        complex,           allocatable :: grVCoul0IR_DM_SF(:, :)
        complex,           allocatable :: grVCoul0MT_DM_SF(:, :, :, :)
        complex,           allocatable :: grVeff0IR_DM(:, :)
        complex,           allocatable :: grVeff0MT_DM(:, :, :, :)
        complex,           allocatable :: grVeff0MT_DMhxc(:, :, :, :)

        INTEGER :: ngdp, iSpin, iType, iR

        WRITE (oUnit,*) '------------------------------------------------------'
        WRITE (oUnit,*) 'This output is generated by juPhon, FLEURs DFPT addon.'
        WRITE (oUnit,*) 'l_dfpt = ', juPhon%l_dfpt
        WRITE (oUnit,*) 'l_jpCheck = ', juPhon%l_jpCheck
        WRITE (oUnit,*) 'l_jpTest = ', juPhon%l_jpTest
        WRITE (oUnit,*) 'l_potout = ', juPhon%l_potout
        WRITE (oUnit,*) 'l_eigout = ', juPhon%l_eigout
        WRITE (oUnit,*) 'l_symTsh = ', juPhon%l_symTsh
        WRITE (oUnit,*) 'l_symTdm = ', juPhon%l_symTdm
        WRITE (oUnit,*) 'l_bfkq = ', juPhon%l_bfkq
        WRITE (oUnit,*) 'jplPlus = ', juPhon%jplPlus
        WRITE (oUnit,*) 'kgqmax = ', juPhon%kgqmax
        WRITE (oUnit,*) 'gqmax = ', juPhon%gqmax
        WRITE (oUnit,*) 'eps_pert = ', juPhon%eps_pert
        WRITE (oUnit,*) 'eDiffCut = ', juPhon%eDiffCut
        WRITE (oUnit,*) 'qpt_ph = ', juPhon%qpt_ph

        IF (juPhon%l_jpCheck) THEN
            ! This function will be used to check the validity of juPhon's
            ! input. I.e. check, whether all prohibited switches are off and,
            ! once there is more expertise considering this topic, check whether
            ! the cutoffs are chosen appropriately.
            CALL dfpt_check()
        END IF

        ! This routine will initialize everything for juPhon that isn't already
        ! provided by the FLEUR code/must be provieded in a modified way.
        ! This includes for example the de-symmetrized MT and pw quantities and
        ! their gradients. Notably, q-dependent quantities are initialized and
        ! constructed elsewhere, within the q-loop.
        CALL dfpt_init(juPhon, sym, input, atoms, sphhar, stars, cell, noco, nococonv, kpts, &
                     & fmpi, results, enpara, rho, vTot, eig_id, nvfull, GbasVec_eig, usdus, rho0, grRho0, vTot0, grVTot0, &
                     & ngdp, El, recG, ngdp2km, gdp2Ind, gdp2iLim, GbasVec, ilst, nRadFun, iloTable, ilo2p, &
                     & uuilon, duilon, ulouilopn, kveclo, rbas1, rbas2, gridf, z0, grVxcIRKern, dKernMTGPts, &
                     & gausWts, ylm, qpwcG, rho1MTCoreDispAt, grVeff0MT_init, grVeff0MT_main, grVext0IR_DM, grVext0MT_DM, &
                     & grVCoul0IR_DM_SF, grVCoul0MT_DM_SF, grVeff0IR_DM, grVeff0MT_DM, grVeff0MT_DMhxc,  tdHS0, loosetdout)

        ! Construct potential without the l=0 prefactor.
        CALL vTotclean%copyPotDen(vTot)

        DO iSpin = 1, input%jspins
            DO iType = 1, atoms%ntype
                DO iR = 1, atoms%jri(iType)
                    vTotclean%mt(iR, 0, iType, iSpin) &
                & = vTotclean%mt(iR, 0, iType, iSpin) * sqrt(fpi_const) / atoms%rmsh(iR, iType)
                END DO
            END DO
        END DO

        ! < Imagine starting a q-grid-loop here. >
        ! < For now we just select one q-point from the input. >

        call solveSternheimerSCC( atoms, sym, stars, lathar, dimens, cell, enpara, usdus, input, kpts, qpts, results, usdus,      &
          & logUnit, ngdp, rbas1, rbas2, kveclo, uuilon, duilon, ulouilopn, &
          & gdp, mapKpq2K, ne, eig, GbasVec, ilst, z, nv, El, nradFun, iloTable, nobd, ilo2p, gdp2Ind,     &
          & gdp2iLim, kpq2kPrVec, qpwcG, iqpt, tdHS0, ylm, grRho0IR, grRho0MT, grVeff0MT_init, grVeff0MT_main, dKernMTGPts,       &! main --> DM for Alex
          & grVxcIRKern, rho1MTCoreDispAt, gausWts, rho1IR, rho1MT, vExt1MT, vEff1IR, vEff1MT, oneSternhCycle, ngpqdp, gpqdp,&
          & vExt1IR_final, vHar1IR_final, vHar1MT_final, rho1MTDelta, vExt1MTDelta, vExt1MTq0, vHar1MTDelta, vHar1MTq0, vXc1MTDelta, &
          & vXc1MTq0, rho0IRpw, rho0MTsh, vEff0IRpwUw, noPtsCon, vExt1MTnoVol, vEff1MTnoVol, vH1MTnoVol, vExt1MTnoVolnoq, grVeff0MT_DMhxc, vExt1noqIR_final, rho1MTz0, vCoul1IRtempNoVol, vCoul1MTtempNoVol )

  call CalcIIEnerg2(atoms, cell, dimens, qpts, stars, input, iqpt, ngdp, gdp, E2ndOrdII)

  call SetupDynamicMatrix( atoms, input, sym, dimens, cell, lathar, stars, kpts, qpts, usdus, results, vTotclean, iqpt, ngdp, ngpqdp, gdp, mlh_atom, nmem_atom,&
    & clnu_atom, rho0IR, rho1IR, rho1MT, vExt1MT, vEff1IR, vEff1MT, vTotclean%pw_w, vTotclean%mt(:, :, :, 1),&
    & rho0MT, E2ndOrdII, El, eig, rbas1, rbas2, iloTable, nv, nobd, ilst, GbasVec, z, kveclo, nRadFun, mapKpq2K, kpq2kPrVec,       &
    & gpqdp, memd_atom, logUnit, vXC0IR, eXCIR, vXC0MT, eXCMT, vExt1IR_final, vHar1IR_final, vHar1MT_final, grRho0IR, grRho0MT, &
    & grVext0IR_DM, grVext0MT_DM, grVeff0IR_DM, grVeff0MT_DM, dynMat, rho1MTDelta, vExt1MTDelta, vExt1MTq0, vHar1MTDelta, vHar1MTq0, &
    & vXc1MTDelta, vXc1MTq0, vExt1MTnoVol, grVeff0MT_DMhxc, vEff1MTnoVol, vH1MTnoVol, vExt1MTnoVolnoq, vExt1noqIR_final, rho1MTz0, &
    & grVCoul0IR_DM_SF, grVCoul0MT_DM_SF, vCoul1IRtempNoVol, vCoul1MTtempNoVol)

    call DiagonalizeDynMat(atoms, qpts, calcEigenVec, dynMat, eigenVals, eigenVecs, iqpt)
    call CalculateFrequencies(atoms, iqpt, eigenVals, eigenFreqs)

        IF (juPhon%l_jpTest) THEN
            ! This function will be used to run (parts of) the test suite for
            ! OG juPhon, as provided by CRG.
            CALL dfpt_test()
        END IF

        ! This is where the magic happens. The Sternheimer equation is solved
        ! iteratively, providing the scf part of dfpt calculations.
        CALL dfpt_sternheimer()

        ! Once the first order quantities are converged, we can construct all
        ! additional quantities necessary and from that the dynamical matrix.
        CALL dfpt_dynmat()

        ! < Imagine ending a q-grid-loop here. >

        WRITE (oUnit,*) '------------------------------------------------------'

        CALL juDFT_end("Phonon calculation finished.")

    END SUBROUTINE dfpt
END MODULE m_dfpt
