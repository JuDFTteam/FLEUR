!--------------------------------------------------------------------------------
! Copyright (c) 2021 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and available as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!--------------------------------------------------------------------------------
MODULE m_dfpt
    USE m_juDFT_time
    USE m_constants
    USE m_types
    USE m_dfpt_check
    USE m_dfpt_test
    USE m_dfpt_init
    USE m_dfpt_sternheimer
    USE m_dfpt_dynmat

    IMPLICIT NONE

CONTAINS
    SUBROUTINE dfpt(juPhon, sym, input, atoms, sphhar, stars, cell, noco, nococonv, &
                  & kpts, qpts, fmpi, results, enpara, rho, vTot, vCoul, vxc, exc, eig_id, nvfull, GbasVec_eig)

        TYPE(t_juPhon),   INTENT(IN)  :: juPhon
        TYPE(t_sym),      INTENT(IN)  :: sym
        TYPE(t_input),    INTENT(IN)  :: input
        TYPE(t_atoms),    INTENT(IN)  :: atoms
        TYPE(t_sphhar),   INTENT(IN)  :: sphhar
        TYPE(t_stars),    INTENT(IN)  :: stars
        TYPE(t_cell),     INTENT(IN)  :: cell
        TYPE(t_noco),     INTENT(IN)  :: noco
        TYPE(t_nococonv), INTENT(IN)  :: nococonv
        TYPE(t_kpts),     INTENT(IN)  :: kpts
        TYPE(t_kpts),     INTENT(IN)  :: qpts
        TYPE(t_mpi),      INTENT(IN)  :: fmpi
        TYPE(t_results),  INTENT(IN)  :: results
        TYPE(t_enpara),   INTENT(IN)  :: enpara
        TYPE(t_potden),   INTENT(IN)  :: rho, vTot, vCoul, vxc, exc
        INTEGER,          INTENT(IN)  :: eig_id
        INTEGER,          INTENT(IN)  :: nvfull(:, :), GbasVec_eig(:, :, :, :)

        TYPE(t_usdus)                 :: usdus
        TYPE(t_jpPotden)              :: rho0, grRho0, vTot0, grVTot0
        type(t_tlmplm)                :: tdHS0
        COMPLEX, ALLOCATABLE          :: loosetdout(:, :, :, :)

        REAL,             ALLOCATABLE :: El(:, :, :, :)
        INTEGER,          ALLOCATABLE :: recG(:, :), GbasVec(:, :), ilst(:, :, :)
        INTEGER                       :: ngdp2km
        INTEGER,          ALLOCATABLE :: gdp2Ind(:, :, :)
        INTEGER                       :: gdp2iLim(2, 3)
        INTEGER,          ALLOCATABLE :: nRadFun(:, :), iloTable(:, :, :), ilo2p(:, :)
        REAL,             ALLOCATABLE :: uuilon(:, :)
        REAL,             ALLOCATABLE :: duilon(:, :)
        REAL,             ALLOCATABLE :: ulouilopn(:, :, :)
        INTEGER,          ALLOCATABLE :: kveclo(:,:)
        REAL,             ALLOCATABLE :: rbas1(:, :, :, :, :)
        REAL,             ALLOCATABLE :: rbas2(:, :, :, :, :)
        REAL,             ALLOCATABLE :: gridf(:, :)
        COMPLEX,          ALLOCATABLE :: z0(:, :, :, :)
        complex,           allocatable :: grVxcIRKern(:)
        real,              allocatable :: dKernMTGPts(:, :, :)
        real,              allocatable :: gausWts(:)
        complex,           allocatable :: ylm(:, :)
        complex,           allocatable :: qpwcG(:, :)
        complex,           allocatable :: rho1MTCoreDispAt(:, :, :, :)
        complex,           allocatable :: grVeff0MT_init(:, :, :, :)
        complex,           allocatable :: grVeff0MT_main(:, :, :, :)
        complex,           allocatable :: grVext0IR_DM(:, :)
        complex,           allocatable :: grVext0MT_DM(:, :, :, :)
        complex,           allocatable :: grVCoul0IR_DM_SF(:, :)
        complex,           allocatable :: grVCoul0MT_DM_SF(:, :, :, :)
        complex,           allocatable :: grVeff0IR_DM(:, :)
        complex,           allocatable :: grVeff0MT_DM(:, :, :, :)
        complex,           allocatable :: grVeff0MT_DMhxc(:, :, :, :)

        INTEGER :: ngdp

        WRITE (oUnit,*) '------------------------------------------------------'
        WRITE (oUnit,*) 'This output is generated by juPhon, FLEURs DFPT addon.'
        WRITE (oUnit,*) 'l_dfpt = ', juPhon%l_dfpt
        WRITE (oUnit,*) 'l_jpCheck = ', juPhon%l_jpCheck
        WRITE (oUnit,*) 'l_jpTest = ', juPhon%l_jpTest
        WRITE (oUnit,*) 'l_potout = ', juPhon%l_potout
        WRITE (oUnit,*) 'l_eigout = ', juPhon%l_eigout
        WRITE (oUnit,*) 'l_symTsh = ', juPhon%l_symTsh
        WRITE (oUnit,*) 'l_symTdm = ', juPhon%l_symTdm
        WRITE (oUnit,*) 'l_bfkq = ', juPhon%l_bfkq
        WRITE (oUnit,*) 'jplPlus = ', juPhon%jplPlus
        WRITE (oUnit,*) 'kgqmax = ', juPhon%kgqmax
        WRITE (oUnit,*) 'gqmax = ', juPhon%gqmax
        WRITE (oUnit,*) 'eps_pert = ', juPhon%eps_pert
        WRITE (oUnit,*) 'eDiffCut = ', juPhon%eDiffCut
        WRITE (oUnit,*) 'qpt_ph = ', juPhon%qpt_ph

        IF (juPhon%l_jpCheck) THEN
            ! This function will be used to check the validity of juPhon's
            ! input. I.e. check, whether all prohibited switches are off and,
            ! once there is more expertise considering this topic, check whether
            ! the cutoffs are chosen appropriately.
            CALL dfpt_check()
        END IF

        ! This routine will initialize everything for juPhon that isn't already
        ! provided by the FLEUR code/must be provieded in a modified way.
        ! This includes for example the de-symmetrized MT and pw quantities and
        ! their gradients. Notably, q-dependent quantities are initialized and
        ! constructed elsewhere, within the q-loop.
        CALL dfpt_init(juPhon, sym, input, atoms, sphhar, stars, cell, noco, nococonv, kpts, &
                     & fmpi, results, enpara, rho, vTot, eig_id, nvfull, GbasVec_eig, usdus, rho0, grRho0, vTot0, grVTot0, &
                     & ngdp, El, recG, ngdp2km, gdp2Ind, gdp2iLim, GbasVec, ilst, nRadFun, iloTable, ilo2p, &
                     & uuilon, duilon, ulouilopn, kveclo, rbas1, rbas2, gridf, z0, grVxcIRKern, dKernMTGPts, &
                     & gausWts, ylm, qpwcG, rho1MTCoreDispAt, grVeff0MT_init, grVeff0MT_main, grVext0IR_DM, grVext0MT_DM, &
                     & grVCoul0IR_DM_SF, grVCoul0MT_DM_SF, grVeff0IR_DM, grVeff0MT_DM, grVeff0MT_DMhxc,  tdHS0, loosetdout)

        ! < Imagine starting a q-grid-loop here. >

        IF (juPhon%l_jpTest) THEN
            ! This function will be used to run (parts of) the test suite for
            ! OG juPhon, as provided by CRG.
            CALL dfpt_test()
        END IF

        ! This is where the magic happens. The Sternheimer equation is solved
        ! iteratively, providing the scf part of dfpt calculations.
        CALL dfpt_sternheimer()

        ! Once the first order quantities are converged, we can construct all
        ! additional quantities necessary and from that the dynamical matrix.
        CALL dfpt_dynmat()

        ! < Imagine ending a q-grid-loop here. >

        WRITE (oUnit,*) '------------------------------------------------------'

        CALL juDFT_end("Phonon calculation finished.")

    END SUBROUTINE dfpt
END MODULE m_dfpt
