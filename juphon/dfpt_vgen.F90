!--------------------------------------------------------------------------------
! Copyright (c) 2022 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and available as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!--------------------------------------------------------------------------------
MODULE m_dfpt_vgen
   USE m_juDFT

CONTAINS

   SUBROUTINE dfpt_vgen(hybdat,field,input,xcpot,atoms,sphhar,stars,vacuum,sym,&
                   cell,oneD,sliceplot,fmpi,results,noco,nococonv,rho0, rho1,vTot1, &
                   ylm, gWghts, fxcMT, fxcIR, gdp, gqdp, ngdp, ngqdp, iDatom, iDtype, qvec, l_ext)
      !--------------------------------------------------------------------------
      ! FLAPW potential perturbation generator (adjusted from vgen.F90)
      !
      ! The full potential is generated by the following main steps:
      !   a) Generation of the Coulomb potential perturbation from
      !      the total density perturbation.
      !   b) Copying of vExt1 to both spins.
      !   c) Generation of xc potential perturbation.
      !
      !--------------------------------------------------------------------------
      USE m_types
      USE m_constants
      !USE m_rotate_int_den_tofrom_local
      !USE m_bfield
      USE m_dfpt_vgen_coulomb
      USE m_dfpt_vgen_xcpot
      !USE m_vgen_finalize
      !USE m_rotate_mt_den_tofrom_local
      !USE m_magnMomFromDen

      IMPLICIT NONE

      TYPE(t_results),   INTENT(INOUT) :: results
      CLASS(t_xcpot),    INTENT(IN)    :: xcpot
      TYPE(t_hybdat),    INTENT(IN)    :: hybdat
      TYPE(t_mpi),       INTENT(IN)    :: fmpi
      TYPE(t_oneD),      INTENT(IN)    :: oneD
      TYPE(t_sliceplot), INTENT(IN)    :: sliceplot
      TYPE(t_input),     INTENT(IN)    :: input
      TYPE(t_field),     INTENT(IN)    :: field
      TYPE(t_vacuum),    INTENT(IN)    :: vacuum
      TYPE(t_noco),      INTENT(IN)    :: noco
      TYPE(t_nococonv),  INTENT(INOUT) :: nococonv
      TYPE(t_sym),       INTENT(IN)    :: sym
      TYPE(t_stars),     INTENT(IN)    :: stars
      TYPE(t_cell),      INTENT(IN)    :: cell
      TYPE(t_sphhar),    INTENT(IN)    :: sphhar
      TYPE(t_atoms),     INTENT(IN)    :: atoms
      TYPE(t_jpPotden),  INTENT(INOUT) :: rho0, rho1
      TYPE(t_jpPotden),  INTENT(INOUT) :: vTot1!, vExt1
      COMPLEX,           INTENT(IN)    :: ylm(:, :)
      REAL,              INTENT(IN)    :: gWghts(:)
      REAL,              INTENT(IN)    :: fxcMT(:, :, :, :)
      COMPLEX,           INTENT(IN)    :: fxcIR(:, :)
      INTEGER,           INTENT(IN)    :: ngdp, ngqdp, iDatom, iDtype
      INTEGER,           INTENT(IN)    :: gdp(:, :), gqdp(:, :)
      REAL,              INTENT(IN)    :: qvec(3)
      LOGICAL,           INTENT(IN)    :: l_ext

      TYPE(t_jpPotden)                   :: workden0, workDen1, denRot

      INTEGER :: i, js
      REAL    :: b(3,atoms%ntype), dummy1(atoms%ntype), dummy2(atoms%ntype)

      IF (fmpi%irank==0) WRITE (oUnit,FMT=8000)
8000  FORMAT (/,/,t10,'DFPT potential generation',/)

      CALL vTot1%resetjpPotDen()
      !CALL vExt1%resetjpPotDen()

#ifndef CPP_OLDINTEL
      ALLOCATE(vTot1%pw_w,mold=vTot1%pw)
#else
      ALLOCATE( vTot1%pw_w(size(vTot%pw,1),size(vTot1%pw,2)))
#endif

      !ALLOCATE(vExt%pw_w(SIZE(vCoul%pw,1),size(vExt%pw,2)))
      !vExt%pw_w = CMPLX(0.0,0.0)

      CALL workDen1%init_jpPotden(3, 1, ngqdp, atoms%jmtd, atoms%lmaxd, atoms%nat, input%jspins, .FALSE.)
      CALL workDen0%init_jpPotden(1, 0, ngdp, atoms%jmtd, atoms%lmaxd, atoms%nat, input%jspins, .FALSE.)

      ! a)
      ! Sum up both spins in den into workden:
      CALL rho1%jp_sum_both_spin(workden1)
      CALL rho0%jp_sum_both_spin(workden0)
      CALL dfpt_vgen_coulomb(1, fmpi, stars, cell, atoms, workden0, workden1, vTot1, iDatom, iDtype, gqdp, ngqdp, gdp, ngdp, qvec, l_ext)

      ! b)
      ! TODO: Add external switch for Coulomb generator, that spits out Vext seperately OR
      !       save vExt1 from iteration zero and stden1 generation [the latter option is much preferred].
      !CALL vExt1%jp_copy_both_spin(vExt1)
      !vExt1%mt(:,:,:,input%jspins,:,:)=vExt1%mt(:,:,:,1,:,:)
      CALL vTot1%jp_copy_both_spin(vTot1)
      vTot1%mt(:,:,:,input%jspins,:,:)=vTot1%mt(:,:,:,1,:,:)

      ! c)
      ! TODO: We won't need a rotation here, but rather some calculation of
      !       real space perturbations in m, \theta, \phi calculated from the
      !       magnetization density perturbation \vec{m}.
      !IF (noco%l_noco) THEN
      !   CALL denRot%init(stars,atoms,sphhar,vacuum,noco,input%jspins,0)
    !     denRot=den
    !     CALL rotate_int_den_to_local(sym,stars,atoms,sphhar,vacuum,cell,input,noco,oneD,denRot)
    !     IF (any(noco%l_unrestrictMT)) CALL rotate_mt_den_to_local(atoms,sphhar,sym,noco,denrot)
    !  END IF

      CALL dfpt_vgen_xcpot(atoms, input%jspins, stars, fmpi, rho1, denRot, ylm, gWghts, fxcMT, fxcIR, iDatom, ngqdp, gqdp, ngdp, gdp, vTot1)

     ! CALL bfield(input,stars,noco,atoms,field,vTot)

      CALL vTot1%jpdistribute(fmpi%mpi_comm)
      !CALL vExt1%jpdistribute(fmpi%mpi_comm)

   END SUBROUTINE dfpt_vgen

END MODULE m_dfpt_vgen
