MODULE m_add_selfen

   USE m_types
   USE m_constants
   USE m_juDFT
   USE m_greensfUtils

   IMPLICIT NONE

   CONTAINS

   SUBROUTINE add_selfen(g,selfen,atoms,gfinp,input,noco,hub1inp,ef,n_occ,gp,mmpMat)

      !Calculates the interacting Green's function for the mt-sphere with
      !
      ! (G)^-1 = (G_0)^-1 - mu 1 + V_dc - selfen + V_U
      !
      !The term mu * unity is there to ensure that the number of particles
      !doesn't change and is determined by a two-step process
      !The occupation as a function of mu has a peak in the region where
      !something is inside the energy interval between e_bot adn e_fermi
      !To determine where we have the same number of particles we first
      !search for the maximum occupation
      !Then the desired chemical potential is found with the bisection method
      !to the right of the maximum

      TYPE(t_greensf),  INTENT(IN)     :: g(:)
      TYPE(t_gfinp),    INTENT(IN)     :: gfinp
      TYPE(t_hub1inp),  INTENT(IN)     :: hub1inp
      TYPE(t_atoms),    INTENT(IN)     :: atoms
      TYPE(t_noco),     INTENT(IN)     :: noco
      TYPE(t_input),    INTENT(IN)     :: input
      COMPLEX,          INTENT(IN)     :: selfen(:,:,:,:,:)
      REAL,             INTENT(IN)     :: ef
      REAL,             INTENT(IN)     :: n_occ(:,:)
      TYPE(t_greensf),  INTENT(INOUT)  :: gp(:)
      COMPLEX,          INTENT(INOUT)  :: mmpMat(-lmaxU_const:,-lmaxU_const:,:,:)

      INTEGER i_hia,l,nType,ns,ispin,m,mp,iz,ipm,i_gf
      INTEGER spin_match,matsize,start,end,i_match
      CHARACTER(len=6) filename

      REAL mu_a,mu_b,mu_step,mu_max,n_max
      REAL mu,n,n_target
      TYPE(t_mat) :: gmat,vmat
      LOGICAL l_match_both_spins,err

      !Interval where we expect the correct mu
      mu_a = -2.0
      mu_b = 1.5
      mu_step = 0.01
      mu_max = 0.0
      n_max = 0.0

      spin_match = MERGE(1,input%jspins,noco%l_soc.AND.noco%l_noco)
      !Not tested yet for two chemical potentials, so we just take one
      spin_match=1
      !Are we matching the spin polarized self-energy with one chemical potential
      l_match_both_spins = spin_match.EQ.1!.AND.input%jspins.EQ.2

      DO i_hia = 1, atoms%n_hia
         l = atoms%lda_u(atoms%n_u+i_hia)%l
         nType = atoms%lda_u(atoms%n_u+i_hia)%atomType
         i_gf = gfinp%hiaElem(i_hia)
         ns = 2*l+1
         matsize = ns*MERGE(2,1,l_match_both_spins)
         CALL vmat%init(.false.,matsize,matsize)
         !Search for the maximum of occupation
         DO i_match = 1, spin_match
            !Target occupation
            n_target = MERGE(SUM(n_occ(i_hia,:)),n_occ(i_hia,i_match),l_match_both_spins)
            WRITE(filename,9000) i_match
#ifdef CPP_DEPUG
            OPEN(unit=1337,file=TRIM(ADJUSTL(filename)),status="replace",action="write")
#endif
            mu = mu_a
            start = MERGE(1,1+(i_match-1)*ns,l_match_both_spins)
            end   = MERGE(2*ns,i_match*ns,l_match_both_spins)
            DO WHILE(mu.LE.mu_b)
               CALL gp(i_gf)%reset()
               mu = mu + mu_step
               DO ipm = 1, 2
                  DO iz = 1, g(i_gf)%contour%nz
                     !Read selfenergy
                     vmat%data_c = selfen(start:end,start:end,iz,ipm,i_hia)
                     IF(.NOT.gfinp%l_mperp.AND.l_match_both_spins) THEN
                        !Dismiss spin-off-diagonal elements
                        vmat%data_c(1:ns,ns+1:2*ns) = 0.0
                        vmat%data_c(ns+1:2*ns,1:ns) = 0.0
                     ENDIF
                     IF(l_match_both_spins) THEN
                        CALL g(i_hia)%get(i_gf,gmat,gfinp,input,iz,ipm.EQ.2)
                     ELSE
                        CALL g(i_hia)%get(i_gf,gmat,gfinp,input,iz,ipm.EQ.2,spin=i_match)
                     ENDIF
                     CALL add_pot(gmat,vmat,mu)
                     IF(l_match_both_spins) THEN
                        CALL gp(i_hia)%set(i_gf,gmat,gfinp,input,iz,ipm.EQ.2)
                     ELSE
                        CALL gp(i_hia)%set(i_gf,gmat,gfinp,input,iz,ipm.EQ.2,spin=i_match)
                     ENDIF
                     CALL gmat%free()
                  ENDDO
               ENDDO
               CALL occmtx(gp(i_hia),i_gf,gfinp,input,mmpMat(:,:,i_hia,:),err,check=.TRUE.)
#ifdef CPP_DEBUG
               !IF(err) CALL gfDOS(gp,l,nType,999,gfinp,input,ef)
#endif
               !Calculate the trace
               n = 0.0
               DO ispin = 1, input%jspins
                  DO m = -l, l
                     n = n + REAL(mmpMat(m,m,i_hia,ispin))
                  ENDDO
               ENDDO
#ifdef CPP_DEBUG
               WRITE(1337,"(2f15.8)") mu,n
#endif
               IF(n.GT.n_max) THEN
                  mu_max = mu
                  n_max  = n
               ENDIF
            ENDDO
#ifdef CPP_DEBUG
            CLOSE(1337)
#endif

            !Sanity check for the maximum occupation
            IF(n_max-2*ns.GT.1) THEN
               !These oscillations seem to emerge when the lorentzian smoothing is done inadequately
               CALL juDFT_error("Something went wrong with the addition of the selfenergy: n_max>>ns",calledby="add_selfen")
            ENDIF

            IF(n_max-n_target.LT.0.0) CALL juDFT_error("Something went wrong with the addition of the selfenergy: n_max<n_target",calledby="add_selfen")

            !Set up the interval for the bisection method (mu_max,mu_b)
            mu_a = mu_max
            DO
               CALL gp(i_hia)%reset()
               mu = (mu_a + mu_b)/2.0
               DO ipm = 1, 2
                  DO iz = 1, g(i_hia)%contour%nz
                     !Read selfenergy
                     vmat%data_c = selfen(start:end,start:end,iz,ipm,i_hia)
                     IF(.NOT.gfinp%l_mperp.AND.l_match_both_spins) THEN
                        !Dismiss spin-off-diagonal elements
                        vmat%data_c(1:ns,ns+1:2*ns) = 0.0
                        vmat%data_c(ns+1:2*ns,1:ns) = 0.0
                     ENDIF
                     IF(l_match_both_spins) THEN
                        CALL g(i_hia)%get(i_gf,gmat,gfinp,input,iz,ipm.EQ.2)
                     ELSE
                        CALL g(i_hia)%get(i_gf,gmat,gfinp,input,iz,ipm.EQ.2,spin=i_match)
                     ENDIF
                     CALL add_pot(gmat,vmat,mu)
                     IF(l_match_both_spins) THEN
                        CALL gp(i_hia)%set(i_gf,gmat,gfinp,input,iz,ipm.EQ.2)
                     ELSE
                        CALL gp(i_hia)%set(i_gf,gmat,gfinp,input,iz,ipm.EQ.2,spin=i_match)
                     ENDIF
                     CALL gmat%free()
                  ENDDO
               ENDDO
               CALL occmtx(gp(i_hia),i_gf,gfinp,input,mmpMat(:,:,i_hia,:),err,check=.TRUE.) !check makes sure that the elements are reasonable
               !Calculate the trace
               n = 0.0
               DO ispin = 1, input%jspins
                  DO m = -l, l
                     n = n + REAL(mmpMat(m,m,i_hia,ispin))
                  ENDDO
               ENDDO
               IF(ABS(n-n_target).LT.0.001.OR.ABS((mu_b - mu_a)/2.0).LT.1e-4) THEN
                  !We found the chemical potential to within the desired accuracy
                  WRITE(6,"(A)") "Calculated mu to match Self-energy to DFT-GF"
                  WRITE(6,"(TR3,A4,f8.4)") "mu = ", mu
                  !----------------------------------------------------
                  ! Check if the final mmpMat contains invalid elements
                  !----------------------------------------------------
                  IF(err) CALL juDFT_error("Invalid Element/occupation in final density matrix",calledby="add_selfen")
                  EXIT
               ELSE IF((n - n_target).GT.0) THEN
                  !The occupation is to big --> choose the right interval
                  mu_a = mu
               ELSE IF((n - n_target).LT.0) THEN
                  !The occupation is to small --> choose the left interval
                  mu_b = mu
               ENDIF
            ENDDO
         ENDDO
         CALL vmat%free()
         !Test throw out elements smaller than 1e-4
         DO ispin = 1, input%jspins
            DO m = -l, l
               DO mp=-l, l
                  IF(ABS(mmpMat(m,mp,i_hia,ispin)).LT.1e-4) mmpMat(m,mp,i_hia,ispin) = 0.0
               ENDDO
            ENDDO
         ENDDO
      ENDDO

9000  FORMAT("mu_",I1)

   END SUBROUTINE add_selfen

   SUBROUTINE add_pot(gmat,vmat,mu)

      TYPE(t_mat),      INTENT(INOUT)  :: gmat
      TYPE(t_mat),      INTENT(IN)     :: vmat
      REAL,             INTENT(IN)     :: mu

      INTEGER i

      IF(vmat%matsize1.NE.gmat%matsize1.OR.vmat%matsize2.NE.gmat%matsize2) &
         CALL juDFT_error("vmat & gmat dimension do not match",hint="This is a bug in FLEUR, please report",calledby="add_pot")

      CALL gmat%inverse()
      gmat%data_c = gmat%data_c - vmat%data_c
      DO i = 1, gmat%matsize1
         gmat%data_c(i,i) = gmat%data_c(i,i) - mu
      ENDDO
      CALL gmat%inverse()

   END SUBROUTINE add_pot

END MODULE m_add_selfen
