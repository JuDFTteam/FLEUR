!--------------------------------------------------------------------------------
! Copyright (c) 2016 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and available as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!--------------------------------------------------------------------------------
MODULE m_fleur
   IMPLICIT NONE
CONTAINS
   SUBROUTINE fleur_execute(mpi,input,field,atoms,sphhar,cell,stars,sym,noco,nococonv,vacuum,forcetheo,sliceplot,&
        banddos,enpara,xcpot,results,kpts,mpinp,hybinp,oneD,coreSpecInput,gfinp,&
        hub1inp,wann)

    !     ***************************************************************
    !
    !     based on flapw7 (c.l.fu, m.weinert, e.wimmer):
    !     full potential linearized augmented plane wave method for thin
    !     films and superlattices (version 7 ---- general symmetry)
    !     symmetry part       ---  e.wimmer
    !     potential generator ---  c.l.fu,r.podloucky
    !     matrix elements     ---  m.weinert
    !     charge density      ---  c.l.fu
    !                                c.l.fu        1987
    !     2nd variation diagon.  --- r.-q. wu      1992
    !     forces a la Yu et al   --- r.podloucky   1995
    !     full relativistic core --- a.shick       1996
    !     broyden mixing         --- r.pentcheva   1996
    !     gga (pw91, pbe)        --- t.asada       1997
    !     local orbitals         --- p.kurz        1997
    !     automatic symmetry     --- w.hofer       1997
    !     core tails & start     --- r.abt         1998
    !     spin orbit coupling    --- a.shick,x.nie 1998
    !     non-colinear magnet.   --- p.kurz        1999
    !     one-dimensional        --- y.mokrousov   2002
    !     exchange parameters    --- m.lezaic      2004
    !
    !                       g.bihlmayer, s.bluegel 1999
    !     ***************************************************************
    !----------------------------------------
    ! this routine is the main PROGRAM

   USE m_types
   USE m_constants
   USE m_optional
   USE m_cdn_io
   USE m_mixing_history
   USE m_qfix
   USE m_vgen
   USE m_vgen_coulomb
   USE m_writexcstuff
   USE m_vmatgen
   USE m_eigen
   USE m_eigenso
   USE m_fermie
   USE m_cdngen
   USE m_totale
   USE m_potdis
   USE m_mix
   USE m_xmlOutput
   USE m_juDFT_time
   USE m_calc_hybrid
   USE m_rdmft
   USE m_io_hybinp
   USE m_wann_optional
   USE m_wannier
   USE m_bs_comfort
   USE m_dwigner
   USE m_ylm
   USE m_metagga
   USE m_plot
   USE m_hubbard1_setup



#ifdef CPP_MPI
   USE m_mpi_bc_potden
#endif
   USE m_eig66_io
   USE m_chase_diag
   USE m_writeBasis

   USE m_alignSpinAxisMagn
   !$ USE omp_lib
   IMPLICIT NONE

   TYPE(t_mpi),INTENT(IN)      :: mpi
   TYPE(t_input),INTENT(IN)    :: input
   TYPE(t_field),INTENT(IN)    :: field 
   TYPE(t_atoms),INTENT(IN)    :: atoms
   TYPE(t_sphhar),INTENT(IN)   :: sphhar
   TYPE(t_cell),INTENT(IN)     :: cell
   TYPE(t_stars),INTENT(IN)    :: stars
   TYPE(t_sym),INTENT(IN)      :: sym
   TYPE(t_noco),INTENT(IN)     :: noco
   TYPE(t_vacuum),INTENT(IN)   :: vacuum
   TYPE(t_sliceplot),INTENT(IN):: sliceplot
   TYPE(t_banddos),INTENT(IN)  :: banddos
   TYPE(t_kpts),INTENT(IN)     :: kpts
   TYPE(t_mpinp),INTENT(IN)    :: mpinp
   TYPE(t_hybinp),INTENT(IN)   :: hybinp
   TYPE(t_oneD),INTENT(IN)     :: oneD
   TYPE(t_coreSpecInput),INTENT(IN):: coreSpecInput
   TYPE(t_gfinp),INTENT(IN)    :: gfinp
   TYPE(t_hub1inp),INTENT(IN)  :: hub1inp
   CLASS(t_xcpot),INTENT(IN)   :: xcpot


   TYPE(t_wann),INTENT(INOUT)     :: wann
   CLASS(t_forcetheo),INTENT(INOUT)::forcetheo
   TYPE(t_results),INTENT(INOUT)  :: results
   TYPE(t_nococonv),INTENT(INOUT) :: nococonv
   TYPE(t_enpara),INTENT(INOUT)   :: enpara

   TYPE(t_input) :: input_soc !same as input with neig=2*neig !should be refactored out

    TYPE(t_field)                   :: field2
    TYPE(t_hybdat)                  :: hybdat
    TYPE(t_mpdata)                  :: mpdata

    TYPE(t_potden)                  :: vTot, vx, vCoul, vTemp, vxcForPlotting
    TYPE(t_potden)                  :: inDen, outDen, EnergyDen

    TYPE(t_greensf)                 :: gOnsite
    TYPE(t_hub1data)                :: hub1data

    ! local scalars
    INTEGER :: eig_id,archiveType, num_threads
    INTEGER :: iter,iterHF,i,n
    INTEGER :: wannierspin
    LOGICAL :: l_opti,l_cont,l_qfix,l_real
    REAL    :: fix, sfscale

#ifdef CPP_MPI
    INCLUDE 'mpif.h'
    INTEGER :: ierr(2)
#endif
    REAL, ALLOCATABLE :: flh(:,:),flh2(:,:)
    COMPLEX, ALLOCATABLE :: flm(:,:)



    IF ( ( input%preconditioning_param /= 0 ) .AND. oneD%odi%d1 ) THEN
      CALL juDFT_error('Currently no preconditioner for 1D calculations', calledby = 'fleur')
    END IF

    CALL optional(mpi,atoms,sphhar,vacuum,&
                              stars,input,sym,cell,sliceplot,xcpot,noco,oneD)

    IF (input%l_wann.AND.(mpi%irank==0).AND.(.NOT.wann%l_bs_comf)) THEN
       IF(mpi%isize.NE.1) CALL juDFT_error('No Wannier+MPI at the moment',calledby = 'fleur')
       CALL wann_optional(input,kpts,atoms,sym,cell,oneD,noco,wann)
    END IF

    iter     = 0
    iterHF   = 0
    hub1data%iter  = 0
    hub1data%l_runthisiter = .FALSE.
    l_cont = (iter < input%itmax)

    IF (mpi%irank.EQ.0) CALL openXMLElementNoAttributes('scfLoop')

    ! Initialize and load inDen density (start)
    CALL inDen%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_DEN)

    archiveType = CDN_ARCHIVE_TYPE_CDN1_const
    IF (noco%l_noco) archiveType = CDN_ARCHIVE_TYPE_NOCO_const
    IF(mpi%irank.EQ.0) THEN
       CALL readDensity(stars,noco,vacuum,atoms,cell,sphhar,input,sym,oneD,archiveType,CDN_INPUT_DEN_const,&
                        0,results%ef,l_qfix,inDen)
       CALL timestart("Qfix")
       CALL qfix(mpi,stars,atoms,sym,vacuum, sphhar,input,cell,oneD,inDen,noco%l_noco,.FALSE.,.false.,fix)
       CALL timestop("Qfix")
       CALL writeDensity(stars,noco,vacuum,atoms,cell,sphhar,input,sym,oneD,archiveType,CDN_INPUT_DEN_const,&
                         0,-1.0,results%ef,.FALSE.,inDen)
    END IF

    IF ((sliceplot%iplot.NE.0 ).AND.(mpi%irank==0) ) THEN
       CALL makeplots(stars, atoms, sphhar, vacuum, input, oneD, sym, cell, &
                      noco,nococonv, inDen, PLOT_INPDEN, sliceplot)
    END IF

    ! Initialize and load inDen density (end)

    ! Initialize potentials (start)
    CALL vTot%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_POTTOT)
    CALL vCoul%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_POTCOUL)
    CALL vx%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_POTCOUL)
    CALL vTemp%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_POTTOT)
    ! Initialize potentials (end)

    ! Initialize Green's function (start)
    IF(gfinp%n>0) CALL gOnsite%init(gfinp,input,noco)
    ! Initialize Green's function (end)
    IF(atoms%n_hia>0) CALL hub1data%init(atoms,hub1inp)

    ! Open/allocate eigenvector storage (start)
    l_real=sym%invs.AND..NOT.noco%l_noco.AND..NOT.(noco%l_soc.AND.atoms%n_u+atoms%n_hia>0)
    if(noco%l_soc.and.input%l_wann)then
    	 !! Weed up and down spinor components for SOC MLWFs.
    	 !! When jspins=1 Fleur usually writes only the up-spinor into the eig-file.
    	 !! Make sure we always get up and down spinors when SOC=true.
       wannierspin=2
    else
       wannierspin = input%jspins
    endif

    eig_id=open_eig(mpi%mpi_comm,lapw_dim_nbasfcn,input%neig,kpts%nkpt,wannierspin,&
                    noco%l_noco,.true.,l_real,noco%l_soc,.false.,mpi%n_size)

#ifdef CPP_CHASE
    CALL init_chase(mpi,input,atoms,kpts,noco,l_real)
#endif
    ! Open/allocate eigenvector storage (end)

    scfloop:DO WHILE (l_cont)

       iter = iter + 1
       IF(hub1data%l_runthisiter.AND.atoms%n_hia>0) THEN
          hub1data%iter = hub1data%iter + 1
          CALL hubbard1_setup(atoms,gfinp,hub1inp,input,mpi,noco,vTot,gOnsite,hub1data,results,inDen)
       ENDIF
       IF (mpi%irank.EQ.0) CALL openXMLElementFormPoly('iteration',(/'numberForCurrentRun','overallNumber      '/),&
                                                       (/iter,inden%iter/), RESHAPE((/19,13,5,5/),(/2,2/)))

!!$       !+t3e
!!$       IF (input%alpha.LT.10.0) THEN
!!$
!!$          IF (iter.GT.1) THEN
!!$             input%alpha = input%alpha - NINT(input%alpha)
!!$          END IF

       !CALL resetIterationDependentTimers()
       CALL timestart("Iteration")
       IF (mpi%irank.EQ.0) THEN
          WRITE (6,FMT=8100) iter
8100      FORMAT (/,10x,'   iter=  ',i5)
       ENDIF !mpi%irank.eq.0

#ifdef CPP_CHASE
       CALL chase_distance(results%last_distance)
#endif

#ifdef CPP_MPI
       CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,inDen)
#endif


       !HF
       IF (hybinp%l_hybrid) THEN
          SELECT TYPE(xcpot)
          TYPE IS(t_xcpot_inbuild)
             CALL calc_hybrid(eig_id,mpinp,mpdata,hybinp,hybdat,kpts,atoms,input,mpi,noco,nococonv,&
                              cell,oneD,enpara,results,sym,xcpot,vTot,iterHF)
          END SELECT
          IF(hybdat%l_calhf) THEN
             call mixing_history_reset(mpi)
             iter = 0
          END IF
       ENDIF
       !RDMFT
       IF(input%l_rdmft) THEN
          CALL open_hybinp_io1(sym%invs)
       END IF

       !IF(.not.input%eig66(1))THEN
          CALL reset_eig(eig_id,noco%l_soc) ! This has to be placed after the calc_hybrid call but before eigen
       !END IF

       !#endif

!!$             DO pc = 1, wann%nparampts
!!$                !---> gwf
!!$                IF (wann%l_sgwf.OR.wann%l_ms) THEN
!!$                   noco%qss(:) = wann%param_vec(:,pc)
!!$                   noco%alph(:) = wann%param_alpha(:,pc)
!!$                ELSE IF (wann%l_socgwf) THEN
!!$                   IF(wann%l_dim(2)) noco%phi   = tpi_const * wann%param_vec(2,pc)
!!$                   IF(wann%l_dim(3)) noco%theta = tpi_const * wann%param_vec(3,pc)
!!$                END IF
       !---< gwf

!START Rot For Testing (HIGHLY EXPERIMENTAL ROUTINE)
    !   IF(.FALSE.)CALL rotateMagnetToSpinAxis(vacuum,sphhar,stars&
    !          ,sym,oneD,cell,noco,input,atoms,inDen)
!END Rot For Testing (HIGHLY EXPERIMENTAL ROUTINE)

       IF (noco%l_sourceFree) THEN
          sfscale=1.0
          IF (xcpot%needs_grad()) THEN
             sfscale=1.14
          ELSE
             sfscale=1.12
          END IF
          CALL inDen%SpinsToChargeAndMagnetisation()
          inDen%mt(:,0:,:,  2:4) = sfscale*inDen%mt(:,0:,:,2:4)
          inDen%pw(:,       2:3) = sfscale*inDen%pw(:,     2:3)
          inDen%vacz(:,:,   2:4) = sfscale*inDen%vacz(:,:, 2:4)
          inDen%vacxy(:,:,:,2:3) = sfscale*inDen%vacxy(:,:,:,2:3)
          CALL inDen%ChargeAndMagnetisationToSpins()
       END IF

       CALL timestart("generation of potential")
       CALL vgen(hybdat,field,input,xcpot,atoms,sphhar,stars,vacuum,sym,&
                 cell,oneD,sliceplot,mpi,results,noco,nococonv,EnergyDen,inDen,vTot,vx,vCoul)
       CALL timestop("generation of potential")

       IF (noco%l_sourceFree) THEN
          CALL inDen%SpinsToChargeAndMagnetisation()
          inDen%mt(:,0:,:,  2:4) = inDen%mt(:,0:,:,2:4)/sfscale
          inDen%pw(:,       2:3) = inDen%pw(:,     2:3)/sfscale
          inDen%vacz(:,:,   2:4) = inDen%vacz(:,:, 2:4)/sfscale
          inDen%vacxy(:,:,:,2:3) = inDen%vacxy(:,:,:,2:3)/sfscale
          CALL inDen%ChargeAndMagnetisationToSpins()
       END IF

       IF ((sliceplot%iplot.NE.0 ).AND.(mpi%irank==0) ) THEN
          CALL makeplots(stars, atoms, sphhar, vacuum, input, oneD, sym, cell, &
                         noco,nococonv, vTot, PLOT_POT_TOT, sliceplot)
          !CALL makeplots(sym,stars,vacuum,atoms,sphhar,input,cell,oneD,noco,sliceplot,vCoul,PLOT_POT_COU)
          !CALL subPotDen(vxcForPlotting,vTot,vCoul)
          !CALL makeplots(sym,stars,vacuum,atoms,sphhar,input,cell,oneD,noco,sliceplot,vxcForPlotting,PLOT_POT_VXC)
       END IF

#ifdef CPP_MPI
       CALL MPI_BARRIER(mpi%mpi_comm,ierr)
#endif
       CALL forcetheo%start(vtot,mpi%irank==0)
       forcetheoloop:DO WHILE(forcetheo%next_job(iter==input%itmax,atoms,noco,nococonv))

          CALL timestart("gen. of hamil. and diag. (total)")
          CALL timestart("eigen")
          vTemp = vTot
          vTemp%mmpMat = 0.0 !To avoid errors later on (When ldaUAdjEnpara is T the density
                             !is carried over after vgen)
          CALL timestart("Updating energy parameters")
          CALL enpara%update(mpi%mpi_comm,atoms,vacuum,input,vToT,hub1inp)
          CALL timestop("Updating energy parameters")
          !IF(.not.input%eig66(1))THEN
            CALL eigen(mpi,stars,sphhar,atoms,xcpot,sym,kpts,vacuum,input,&
                       cell,enpara,banddos,noco,nococonv,oneD,mpdata,hybinp,hybdat,&
                       iter,eig_id,results,inDen,vTemp,vx,hub1inp,hub1data)
          !ENDIF
          vTot%mmpMat = vTemp%mmpMat
!!$          eig_idList(pc) = eig_id
          CALL timestop("eigen")

          ! add all contributions to total energy
#ifdef CPP_MPI
          ! send all result of local total energies to the r
          IF (hybinp%l_hybrid.AND.hybdat%l_calhf) THEN
             IF (mpi%irank==0) THEN
                CALL MPI_Reduce(MPI_IN_PLACE,results%te_hfex%core,1,MPI_REAL8,MPI_SUM,0,mpi%mpi_comm,ierr(1))
             ELSE
                CALL MPI_Reduce(results%te_hfex%core,MPI_IN_PLACE,1,MPI_REAL8,MPI_SUM,0, mpi%mpi_comm,ierr(1))
             END IF
             IF (mpi%irank==0) THEN
                CALL MPI_Reduce(MPI_IN_PLACE,results%te_hfex%valence,1,MPI_REAL8,MPI_SUM,0,mpi%mpi_comm,ierr(1))
             ELSE
                CALL MPI_Reduce(results%te_hfex%valence,MPI_IN_PLACE,1,MPI_REAL8,MPI_SUM,0, mpi%mpi_comm,ierr(1))
             END IF
          END IF
#endif

          ! WRITE(6,fmt='(A)') 'Starting 2nd variation ...'
          IF (noco%l_soc.AND..NOT.noco%l_noco) &
             CALL eigenso(eig_id,mpi,stars,vacuum,atoms,sphhar,&
                          sym,cell,noco,nococonv,input,kpts, oneD,vTot,enpara,results,hub1inp,hub1data)
          CALL timestop("gen. of hamil. and diag. (total)")

#ifdef CPP_MPI
          CALL MPI_BARRIER(mpi%mpi_comm,ierr)
#endif

          ! fermi level and occupancies
          input_soc=input
          IF (noco%l_soc.AND.(.NOT.noco%l_noco)) then
            input_soc=input
            input_soc%neig = 2*input%neig
          ENDIF

	  IF (input%gw.GT.0) THEN
	    IF (mpi%irank.EQ.0) THEN
	       CALL writeBasis(input_soc,noco,nococonv,kpts,atoms,sym,cell,enpara,hub1inp,vTot,vCoul,vx,mpi,&
		  	     results,eig_id,oneD,sphhar,stars,vacuum)
	    END IF
	    IF (input%gw.EQ.2) THEN
	       CALL juDFT_end("GW data written. Fleur ends.",mpi%irank)
	    END IF
	  END IF

          !IF ((mpi%irank.EQ.0)) THEN
             CALL timestart("determination of fermi energy")

             IF (noco%l_soc.AND.(.NOT.noco%l_noco)) THEN
                input_soc%zelec = input%zelec*2
                CALL fermie(eig_id,mpi,kpts,input_soc,noco,enpara%epara_min,cell,results)
                results%seigscv = results%seigscv/2
                results%ts = results%ts/2
             ELSE
                CALL fermie(eig_id,mpi,kpts,input,noco,enpara%epara_min,cell,results)
             ENDIF
             CALL timestop("determination of fermi energy")

!!$          !+Wannier
!!$          IF(wann%l_bs_comf)THEN
!!$             IF(pc.EQ.1) THEN
!!$                OPEN(777,file='out_eig.1')
!!$                OPEN(778,file='out_eig.2')
!!$                OPEN(779,file='out_eig.1_diag')
!!$                OPEN(780,file='out_eig.2_diag')
!!$             END IF
!!$
!!$             CALL bs_comfort(eig_id,input,noco,kpts%nkpt,pc)
!!$
!!$             IF(pc.EQ.wann%nparampts)THEN
!!$                CLOSE(777)
!!$                CLOSE(778)
!!$                CLOSE(779)
!!$                CLOSE(780)
!!$             END IF
!!$          END IF
!!$          !-Wannier

          !ENDIF
#ifdef CPP_MPI
          CALL MPI_BCAST(results%ef,1,MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
          CALL MPI_BCAST(results%w_iks,SIZE(results%w_iks),MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
#endif

          IF (forcetheo%eval(eig_id,atoms,kpts,sym,cell,noco,nococonv,input_soc,mpi,oneD,enpara,vToT,results)) THEN
             CYCLE forcetheoloop
          ENDIF


          !+Wannier functions
          IF ((input%l_wann).AND.(.NOT.wann%l_bs_comf)) THEN
             CALL wannier(mpi,input_soc,kpts,sym,atoms,stars,vacuum,sphhar,oneD,&
                  wann,noco,nococonv,cell,enpara,banddos,sliceplot,vTot,results,&
                  (/eig_id/),(sym%invs).AND.(.NOT.noco%l_soc).AND.(.NOT.noco%l_noco),kpts%nkpt)
          END IF
          !-Wannier

          ! charge density generation
          CALL timestart("generation of new charge density (total)")
          CALL outDen%init(stars,atoms,sphhar,vacuum,noco,input%jspins,POTDEN_TYPE_DEN)
          outDen%iter = inDen%iter
          CALL cdngen(eig_id,mpi,input_soc,banddos,sliceplot,vacuum, &
                      kpts,atoms,sphhar,stars,sym,gfinp,hub1inp,&
                      enpara,cell,noco,nococonv,vTot,results,oneD,coreSpecInput,&
                      archiveType,xcpot,outDen,EnergyDen,gOnsite,hub1data)
          !The density matrix for DFT+Hubbard1 only changes in hubbard1_setup and is kept constant otherwise
          outDen%mmpMat(:,:,atoms%n_u+1:atoms%n_u+atoms%n_hia,:) = inDen%mmpMat(:,:,atoms%n_u+1:atoms%n_u+atoms%n_hia,:)
          IF ((sliceplot%iplot.NE.0 ).AND.(mpi%irank==0) ) THEN
!               CDN including core charge
               ! CALL makeplots(stars, atoms, sphhar, vacuum, input, oneD, sym, &
!                               cell, noco, outDen, PLOT_OUTDEN_Y_CORE, sliceplot)
!!               CDN subtracted by core charge
               ! CALL makeplots(stars, atoms, sphhar, vacuum, input, oneD, sym, &
!                               cell, noco, outDen, PLOT_OUTDEN_N_CORE, sliceplot)
          END IF

          IF (input%l_rdmft) THEN
             SELECT TYPE(xcpot)
                TYPE IS(t_xcpot_inbuild)
                   CALL rdmft(eig_id,mpi,input_soc,kpts,banddos,sliceplot,cell,atoms,enpara,stars,vacuum,&
                              sphhar,sym,field,vTot,vCoul,oneD,noco,nococonv,xcpot,mpinp,mpdata,hybinp,hybdat,&
                              gfinp,hub1inp,results,coreSpecInput,archiveType,outDen)
             END SELECT
          END IF


#ifdef CPP_MPI
          CALL MPI_BCAST(enpara%evac,SIZE(enpara%evac),MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
          CALL MPI_BCAST(enpara%evac0,SIZE(enpara%evac0),MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
          CALL MPI_BCAST(enpara%el0,SIZE(enpara%el0),MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
          CALL MPI_BCAST(enpara%ello0,SIZE(enpara%ello0),MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)

          IF (noco%l_noco) THEN
             DO n= 1,atoms%ntype
                IF (noco%l_relax(n)) THEN
                   CALL MPI_BCAST(nococonv%alph(n),1,MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
                   CALL MPI_BCAST(nococonv%beta(n),1,MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
                ENDIF
             ENDDO
             IF (noco%l_constr) THEN
                CALL MPI_BCAST(nococonv%b_con,SIZE(nococonv%b_con),MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
             ENDIF
          ENDIF
#endif
          CALL timestop("generation of new charge density (total)")
!START Rot For Testing (HIGHLY EXPERIMENTAL ROUTINE)
!IF (.FALSE.) CALL rotateMagnetFromSpinAxis(noco,vacuum,sphhar,stars,sym,oneD,cell,input,atoms,outDen,inDen)
!END Rot For Testing (HIGHLY EXPERIMENTAL ROUTINE)
!!$             !----> output potential and potential difference
!!$             IF (disp) THEN
!!$                reap = .FALSE.
!!$                CALL timestart("generation of potential (total)")
!!$                CALL vgen(hybinp,reap,input,xcpot, atoms,sphhar,stars,vacuum,sym,&
!!$                     cell,oneD,sliceplot,mpi, results,noco,outDen,inDenRot,vTot,vx,vCoul)
!!$                CALL timestop("generation of potential (total)")
!!$
!!$                CALL potdis(stars,vacuum,atoms,sphhar, input,cell,sym)
!!$             END IF

             ! total energy
             CALL timestart('determination of total energy')
             CALL totale(mpi,atoms,sphhar,stars,vacuum,sym,input,noco,cell,oneD,&
                         xcpot,hybdat,vTot,vCoul,iter,inDen,results)
             CALL timestop('determination of total energy')
          IF (hybinp%l_hybrid) CALL close_eig(eig_id)

       END DO forcetheoloop

       CALL forcetheo%postprocess()

       CALL enpara%mix(mpi%mpi_comm,atoms,vacuum,input,vTot%mt(:,0,:,:),vtot%vacz)
       field2 = field
       ! mix input and output densities
       CALL mix_charge(field2,mpi,(iter==input%itmax.OR.judft_was_argument("-mix_io")),&
            stars,atoms,sphhar,vacuum,input,&
            sym,cell,noco,oneD,archiveType,xcpot,iter,inDen,outDen,results,hub1data%l_runthisiter)
!Plots of mixed density
       IF ((sliceplot%iplot.NE.0 ).AND.(mpi%irank==0) ) THEN
!               CDN including core charge
!                CALL makeplots(stars, atoms, sphhar, vacuum, input, oneD, sym, &
!                               cell, noco, outDen, PLOT_MIXDEN_Y_CORE, sliceplot)
!!               CDN subtracted by core charge
!                CALL makeplots(sym,stars,vacuum,atoms,sphhar,input,cell,oneD,noco,sliceplot,inDen,PLOT_MIXDEN_N_CORE)
!                CALL makeplots(stars, atoms, sphhar, vacuum, input, oneD, sym, &
!                               cell, noco, outDen, PLOT_OUTDEN_N_CORE, sliceplot)
       END IF

       IF(mpi%irank == 0) THEN
         WRITE (6,FMT=8130) iter
8130     FORMAT (/,5x,'******* it=',i3,'  is completed********',/,/)
         WRITE(*,*) "Iteration:",iter," Distance:",results%last_distance
         !Write out information if a hubbard 1 Iteration was performed
         IF(hub1data%l_runthisiter)  THEN
            WRITE(*,*) "Hubbard 1 Iteration: ", hub1data%iter," Distance: ", results%last_mmpMatdistance
            WRITE(6,*) "nmmp occupation distance: ", results%last_occdistance
            WRITE(6,*) "nmmp element distance: ", results%last_mmpMatdistance
            WRITE(6,FMT=8140) hub1data%iter
8140        FORMAT (/,5x,'******* Hubbard 1 it=',i3,'  is completed********',/,/)
         ENDIF
         CALL timestop("Iteration")
       END IF ! mpi%irank.EQ.0

#ifdef CPP_MPI
       CALL MPI_BCAST(results%last_distance,1,MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
       CALL MPI_BCAST(results%last_occdistance,1,MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
       CALL MPI_BCAST(results%last_mmpMatdistance,1,MPI_DOUBLE_PRECISION,0,mpi%mpi_comm,ierr)
       CALL MPI_BARRIER(mpi%mpi_comm,ierr)
#endif
       CALL priv_geo_end(mpi)

       l_cont = .TRUE.
       IF (hybinp%l_hybrid) THEN
          IF(hybdat%l_calhf) THEN
             l_cont = l_cont.AND.(iterHF < input%itmax)
             l_cont = l_cont.AND.(input%mindistance<=results%last_distance)
             CALL check_time_for_next_iteration(iterHF,l_cont)
          ELSE
             l_cont = l_cont.AND.(iter < 50) ! Security stop for non-converging nested PBE calculations
          END IF
          IF (hybdat%l_subvxc) THEN
             results%te_hfex%valence = 0
          END IF
       ELSE
          l_cont = l_cont.AND.(iter < input%itmax)
          ! MetaGGAs need a at least 2 iterations
          l_cont = l_cont.AND.((input%mindistance<=results%last_distance).OR.input%l_f &
                               .OR. (xcpot%exc_is_MetaGGA() .and. iter == 1))
          !If we have converged run hia if the density matrix has not converged
          IF(atoms%n_hia>0) THEN
             hub1data%l_runthisiter = .NOT.l_cont.AND.(hub1inp%minoccDistance<=results%last_occdistance&
                                  .OR.hub1inp%minmatDistance<=results%last_mmpMatdistance)
             !Run after first overall iteration to generate a starting density matrix
             hub1data%l_runthisiter = hub1data%l_runthisiter.OR.(iter==1.AND.(hub1data%iter == 0&
                                  .AND.ALL(ABS(vTot%mmpMat(:,:,atoms%n_u+1:atoms%n_u+atoms%n_hia,:)).LT.1e-12)))
             hub1data%l_runthisiter = hub1data%l_runthisiter.AND.(iter < input%itmax)
             !Prevent that the scf loop terminates
             l_cont = l_cont.OR.hub1data%l_runthisiter
          ENDIF
          CALL check_time_for_next_iteration(iter,l_cont)
       END IF

       !CALL writeTimesXML()

       IF (mpi%irank.EQ.0) THEN
          IF (isCurrentXMLElement("iteration")) CALL closeXMLElement('iteration')
       END IF

  !Break SCF loop if Plots were generated in ongoing run (iplot=/=0).
       IF(sliceplot%iplot.NE.0) THEN
          CALL juDFT_end("Stopped self consistency loop after plots have been generated.")
       END IF

    END DO scfloop ! DO WHILE (l_cont)

    CALL add_usage_data("Iterations",iter)

    IF (mpi%irank.EQ.0) CALL closeXMLElement('scfLoop')

    CALL close_eig(eig_id)
    CALL juDFT_end("all done",mpi%irank)
  CONTAINS
    SUBROUTINE priv_geo_end(mpi)
      TYPE(t_mpi),INTENT(IN)::mpi
      LOGICAL :: l_exist
      !Check if a new input was generated
      INQUIRE (file='inp_new',exist=l_exist)
      IF (l_exist) THEN
         CALL juDFT_end(" GEO new inp created ! ",mpi%irank)
      END IF
      !check for inp.xml
      INQUIRE (file='inp_new.xml',exist=l_exist)
      IF (.NOT.l_exist) RETURN
      IF (mpi%irank==0) THEN
         CALL system('mv inp.xml inp_old.xml')
         CALL system('mv inp_new.xml inp.xml')
         INQUIRE (file='qfix',exist=l_exist)
         IF (l_exist) THEN
            CALL juDFT_end(" GEO new inp created ! ",mpi%irank)
         END IF
         !check for inp.xml
         INQUIRE (file='inp_new.xml',exist=l_exist)
         IF (.NOT.l_exist) RETURN
         IF (mpi%irank==0) THEN
            CALL system('mv inp.xml inp_old.xml')
            CALL system('mv inp_new.xml inp.xml')
            INQUIRE (file='qfix',exist=l_exist)
            IF (l_exist) THEN
               OPEN(2,file='qfix')
               WRITE(2,*)"F"
               CLOSE(2)
               PRINT *,"qfix set to F"
            ENDIF
            CALL mixing_history_reset(mpi)
         ENDIF
         call mixing_history_reset(mpi)
      ENDIF
      CALL juDFT_end(" GEO new inp.xml created ! ",mpi%irank)
    END SUBROUTINE priv_geo_end

  END SUBROUTINE fleur_execute
END MODULE m_fleur
