!--------------------------------------------------------------------------------
! Copyright (c) 2016 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and available as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!--------------------------------------------------------------------------------
MODULE m_vgen
   USE m_juDFT

CONTAINS

   SUBROUTINE vgen(hybdat,field,input,xcpot,atoms,sphhar,stars,vacuum,sym,&
                   cell,oneD,sliceplot,mpi,results,noco,nococonv,EnergyDen,den,vTot,vx,vCoul)
      !--------------------------------------------------------------------------
      ! FLAPW potential generator (main routine)                          
      ! 
      ! The full potential is generated by the following main steps:
      !   a) Generation of Coulomb potential from the total density.
      !   b) Copying of VCoul to both spins.
      !   c) Generation of XC potential.
      !   d) Finalizations including e.g. rescaling and rotations.
      ! 
      ! In results we store:
      !   TE_VCOUL : charge density-coulomb potential integral
      !   TE_VEFF  : charge density-effective potential integral
      !   TE_EXC   : charge density-xc-energy density integral
      !--------------------------------------------------------------------------
      USE m_types
      USE m_rotate_int_den_tofrom_local
      USE m_bfield
      USE m_vgen_coulomb
      USE m_vgen_xcpot
      USE m_vgen_finalize
      USE m_rotate_mt_den_tofrom_local
      USE m_magnMomFromDen
#ifdef CPP_MPI
      USE m_mpi_bc_potden
#endif

      IMPLICIT NONE

      TYPE(t_results),   INTENT(INOUT) :: results
      CLASS(t_xcpot),    INTENT(IN)    :: xcpot
      TYPE(t_hybdat),    INTENT(IN)    :: hybdat
      TYPE(t_mpi),       INTENT(IN)    :: mpi
      TYPE(t_oneD),      INTENT(IN)    :: oneD
      TYPE(t_sliceplot), INTENT(IN)    :: sliceplot
      TYPE(t_input),     INTENT(IN)    :: input
      TYPE(t_field),     INTENT(IN)    :: field  
      TYPE(t_vacuum),    INTENT(IN)    :: vacuum
      TYPE(t_noco),      INTENT(IN)    :: noco
      TYPE(t_nococonv),  INTENT(INOUT) :: nococonv
      TYPE(t_sym),       INTENT(IN)    :: sym
      TYPE(t_stars),     INTENT(IN)    :: stars
      TYPE(t_cell),      INTENT(IN)    :: cell
      TYPE(t_sphhar),    INTENT(IN)    :: sphhar
      TYPE(t_atoms),     INTENT(IN)    :: atoms
      TYPE(t_potden),    INTENT(IN)    :: EnergyDen
      TYPE(t_potden),    INTENT(INOUT) :: den
      TYPE(t_potden),    INTENT(INOUT) :: vTot, vx, vCoul

      TYPE(t_potden)                   :: workden, denRot

      INTEGER :: i
      COMPLEX :: mmpmat(-lmaxU_const:lmaxU_const,-lmaxU_const:lmaxU_const, &
                        MAX(1,atoms%n_u+atoms%n_hia),MERGE(3,input%jspins,noco%l_mperp))
      REAL    :: b(3,atoms%ntype), dummy1(atoms%ntype), dummy2(atoms%ntype)

      IF (noco%l_sourceFree) THEN
         CALL magnMomFromDen(input,atoms,noco,den,b,dummy1,dummy2)
         DO i=1,atoms%ntype
            WRITE  (6,8025) i,b(1,i),b(2,i),b(3,i),SQRT(b(1,i)**2+b(2,i)**2+b(3,i)**2)
            8025 FORMAT(2x,'Magmom before SF [local frame, atom ',i2,']: ','mx=',f9.5,' my=',f9.5,' mz=',f9.5,' |m|=',f9.5)
         END DO
      END IF

      IF (mpi%irank==0) WRITE (6,FMT=8000)
8000  FORMAT (/,/,t10,' p o t e n t i a l   g e n e r a t o r',/)

      IF(atoms%n_u+atoms%n_hia>0.AND.input%ldaUAdjEnpara) THEN
         !In this case we need the last mmpmat after vgen
         mmpmat = vTot%mmpmat
      END IF

      CALL vTot%resetPotDen()
      CALL vCoul%resetPotDen()
      CALL vx%resetPotDen()

      IF(atoms%n_u+atoms%n_hia>0.AND.input%ldaUAdjEnpara) THEN
         !In this case we need the last mmpmat after vgen
         vTot%mmpmat = mmpmat
      END IF

      ALLOCATE(vx%pw_w,mold=vTot%pw)
      vx%pw_w = 0.0

#ifndef CPP_OLDINTEL
      ALLOCATE(vTot%pw_w,mold=vTot%pw)
#else
      ALLOCATE( vTot%pw_w(size(vTot%pw,1),size(vTot%pw,2)))
#endif

      ALLOCATE(vCoul%pw_w(SIZE(vCoul%pw,1),size(vCoul%pw,2)))
      vCoul%pw_w = CMPLX(0.0,0.0)

      CALL workDen%init(stars,atoms,sphhar,vacuum,noco,input%jspins,0)
      
      ! a)
      ! Sum up both spins in den into workden:
      CALL den%sum_both_spin(workden)

      CALL vgen_coulomb(1,mpi,oneD,input,field,vacuum,sym,stars,cell,sphhar,atoms,.FALSE.,workden,vCoul,results)
      
      ! b)
      CALL vCoul%copy_both_spin(vTot)
      vCoul%mt(:,:,:,input%jspins)=vCoul%mt(:,:,:,1)

      ! c)
      IF (noco%l_noco) THEN
         CALL denRot%init(stars,atoms,sphhar,vacuum,noco,input%jspins,0)
         denRot=den
         CALL rotate_int_den_to_local(sym,stars,atoms,sphhar,vacuum,cell,input,noco,oneD,denRot)
         IF (noco%l_mtnocoPot) CALL rotate_mt_den_to_local(atoms,sphhar,sym,noco,denrot)
      END IF

      CALL vgen_xcpot(hybdat,input,xcpot,atoms,sphhar,stars,vacuum,sym,&
                      cell,oneD,sliceplot,mpi,noco,den,denRot,EnergyDen,vTot,vx,results)

      ! d)
      ! TODO: Check if this is needed for more potentials as well!
      CALL vgen_finalize(mpi,oneD,field,cell,atoms,stars,vacuum,sym,noco,nococonv,input,xcpot,sphhar,vTot,vCoul,denRot,sliceplot)
      !DEALLOCATE(vcoul%pw_w)

      CALL bfield(input,noco,atoms,field,vTot)

#ifdef CPP_MPI
      CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,vTot)
      CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,vCoul)
      CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,vx)
#endif
   END SUBROUTINE vgen

END MODULE m_vgen
