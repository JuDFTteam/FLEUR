!--------------------------------------------------------------------------------
! Copyright (c) 2016 Peter Grünberg Institut, Forschungszentrum Jülich, Germany
! This file is part of FLEUR and available as free software under the conditions
! of the MIT license as expressed in the LICENSE file in more detail.
!--------------------------------------------------------------------------------
MODULE m_vgen

   USE m_juDFT

CONTAINS
   !> FLAPW potential generator
   !! The full potential is generated by the following main steps:
   !! * generation of Coulomb potential
   !! * copy of VCoul to both spins
   !! * generation of XC potential
   !! In addition, the rotation of the density in the noco case and some scaling is done
   !! In results we store:
   !!     TE_VCOUL  :   charge density-coulomb potential integral
   !!     TE_VEFF:   charge density-effective potential integral
   !!     TE_EXC :   charge density-ex-corr.energy density integral

   SUBROUTINE vgen(hybrid,field,input,xcpot,DIMENSION,atoms,sphhar,stars,vacuum,sym,&
                   obsolete,cell,oneD,sliceplot,mpi,results,noco,EnergyDen,den,vTot,vx,vCoul)

      USE m_types
      USE m_rotate_int_den_to_local
      USE m_bfield
      USE m_vgen_coulomb
      USE m_vgen_xcpot
      USE m_vgen_finalize
      USE m_rotate_mt_den_tofrom_local
#ifdef CPP_MPI
      USE m_mpi_bc_potden
#endif
      IMPLICIT NONE

      TYPE(t_results),   INTENT(INOUT)  :: results
      CLASS(t_xcpot),    INTENT(INOUT)  :: xcpot
      TYPE(t_hybrid),    INTENT(IN)     :: hybrid
      TYPE(t_mpi),       INTENT(IN)     :: mpi
      TYPE(t_dimension), INTENT(IN)     :: dimension
      TYPE(t_oneD),      INTENT(IN)     :: oneD
      TYPE(t_obsolete),  INTENT(IN)     :: obsolete
      TYPE(t_sliceplot), INTENT(IN)     :: sliceplot
      TYPE(t_input),     INTENT(IN)     :: input
      TYPE(t_field),     INTENT(INOUT)  :: field  !efield can be modified
      TYPE(t_vacuum),    INTENT(IN)     :: vacuum
      TYPE(t_noco),      INTENT(INOUT)  :: noco
      TYPE(t_sym),       INTENT(IN)     :: sym
      TYPE(t_stars),     INTENT(IN)     :: stars
      TYPE(t_cell),      INTENT(IN)     :: cell
      TYPE(t_sphhar),    INTENT(IN)     :: sphhar
      TYPE(t_atoms),     INTENT(IN)     :: atoms
      TYPE(t_potden),    INTENT(IN)     :: EnergyDen
      TYPE(t_potden),    INTENT(INOUT)  :: den
      TYPE(t_potden),    INTENT(INOUT)  :: vTot,vx,vCoul

      TYPE(t_potden)                    :: workden,denRot

      if (mpi%irank==0) WRITE (6,FMT=8000)
8000  FORMAT (/,/,t10,' p o t e n t i a l   g e n e r a t o r',/)

      CALL vTot%resetPotDen()
      CALL vCoul%resetPotDen()
      CALL vx%resetPotDen()
      ALLOCATE(vx%pw_w,mold=vTot%pw)
#ifndef CPP_OLDINTEL
      ALLOCATE(vTot%pw_w,mold=vTot%pw)
#else
      ALLOCATE( vTot%pw_w(size(vTot%pw,1),size(vTot%pw,2)))
#endif
      ALLOCATE(vCoul%pw_w(SIZE(vCoul%pw,1),size(vCoul%pw,2)))
      vCoul%pw_w = CMPLX(0.0,0.0)

      CALL workDen%init(stars,atoms,sphhar,vacuum,noco,input%jspins,0)

      !sum up both spins in den into workden
      CALL den%sum_both_spin(workden)

      CALL vgen_coulomb(1,mpi,dimension,oneD,input,field,vacuum,sym,stars,cell,sphhar,atoms,workden,vCoul,results)

      CALL vCoul%copy_both_spin(vTot)
      vCoul%mt(:,:,:,input%jspins)=vCoul%mt(:,:,:,1)

      IF (noco%l_noco) THEN
         CALL denRot%init(stars,atoms,sphhar,vacuum,noco,input%jspins,0)
         denRot=den
         CALL rotate_int_den_to_local(DIMENSION,sym,stars,atoms,sphhar,vacuum,cell,input,noco,oneD,denRot)
         IF (noco%l_mtnocoPot) CALL rotate_mt_den_to_local(atoms,sphhar,sym,denrot)         
      ENDIF

      CALL vgen_xcpot(hybrid,input,xcpot,dimension,atoms,sphhar,stars,vacuum,sym,&
                      obsolete,cell,oneD,sliceplot,mpi,noco,den,denRot,EnergyDen,vTot,vx,results)

      !ToDo, check if this is needed for more potentials as well...
      CALL vgen_finalize(atoms,stars,vacuum,sym,noco,input,sphhar,vTot,vCoul,denRot)
      !DEALLOCATE(vcoul%pw_w)

      CALL bfield(input,noco,atoms,field,vTot)

#ifdef CPP_MPI
      CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,vTot)
      CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,vCoul)
      CALL mpi_bc_potden(mpi,stars,sphhar,atoms,input,vacuum,oneD,noco,vx)
#endif

      call integrate_lapl(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco) 
      call integrate_kED_schr(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco) 
      call integrate_kED_libxc(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco)
   END SUBROUTINE vgen

   SUBROUTINE integrate_lapl(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco)
      use m_cdntot
      use m_types
      implicit none
      CLASS(t_xcpot),INTENT(IN) :: xcpot
      TYPE(t_stars),INTENT(IN)  :: stars
      TYPE(t_atoms),INTENT(IN)  :: atoms
      TYPE(t_sym),INTENT(IN)    :: sym
      TYPE(t_vacuum),INTENT(IN) :: vacuum
      TYPE(t_input),INTENT(IN)  :: input
      TYPE(t_cell),INTENT(IN)   :: cell
      TYPE(t_oneD),INTENT(IN)   :: oneD
      TYPE(t_sphhar), INTENT(IN):: sphhar
      TYPE(t_noco), INTENT(INOUT)   :: noco
      
      REAL :: q(input%jspins), qis(input%jspins), qmt(atoms%ntype,input%jspins),&
              qvac(2,input%jspins), qtot, qistot

      if(allocated(xcpot%is_lapl%grid)) then
         call integrate_grid(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco,&
                             xcpot%is_lapl, xcpot%mt_lapl, &
                             q, qis, qmt, qvac, qtot, qistot)

         call print_qs(q,qis,qmt,qvac,qtot,qistot,"laplace")
      endif
   END SUBROUTINE integrate_lapl
   
   SUBROUTINE integrate_kED_schr(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco)
      use m_cdntot
      use m_types
      implicit none
      CLASS(t_xcpot),INTENT(IN) :: xcpot
      TYPE(t_stars),INTENT(IN)  :: stars
      TYPE(t_atoms),INTENT(IN)  :: atoms
      TYPE(t_sym),INTENT(IN)    :: sym
      TYPE(t_vacuum),INTENT(IN) :: vacuum
      TYPE(t_input),INTENT(IN)  :: input
      TYPE(t_cell),INTENT(IN)   :: cell
      TYPE(t_oneD),INTENT(IN)   :: oneD
      TYPE(t_sphhar), INTENT(IN):: sphhar
      TYPE(t_noco), INTENT(INOUT)   :: noco
      
      REAL :: q(input%jspins), qis(input%jspins), qmt(atoms%ntype,input%jspins),&
              qvac(2,input%jspins), qtot, qistot

      if(allocated(xcpot%is_kED_schr%grid) .and. allocated(xcpot%mt_kED_schr)) then
         call integrate_grid(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco,&
                             xcpot%is_kED_schr, xcpot%mt_kED_schr, &
                             q, qis, qmt, qvac, qtot, qistot)

         call print_qs(q,qis,qmt,qvac,qtot,qistot,"kED_schr")
      endif

   END SUBROUTINE integrate_kED_schr

   SUBROUTINE integrate_kED_libxc(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco)
      use m_cdntot
      use m_types
      implicit none
      CLASS(t_xcpot),INTENT(IN) :: xcpot
      TYPE(t_stars),INTENT(IN)  :: stars
      TYPE(t_atoms),INTENT(IN)  :: atoms
      TYPE(t_sym),INTENT(IN)    :: sym
      TYPE(t_vacuum),INTENT(IN) :: vacuum
      TYPE(t_input),INTENT(IN)  :: input
      TYPE(t_cell),INTENT(IN)   :: cell
      TYPE(t_oneD),INTENT(IN)   :: oneD
      TYPE(t_sphhar), INTENT(IN):: sphhar
      TYPE(t_noco), INTENT(INOUT)   :: noco
      
      REAL :: q(input%jspins), qis(input%jspins), qmt(atoms%ntype,input%jspins),&
              qvac(2,input%jspins), qtot, qistot
      TYPE(t_grid)              :: is_kED_libxc
      TYPE(t_grid), allocatable :: mt_kED_libxc(:)
      INTEGER                   :: i

      if(allocated(xcpot%is_kED_schr%grid) .and. allocated(xcpot%mt_kED_schr)) then
         allocate(mt_kED_libxc(size(xcpot%mt_kED_schr)))
         
         is_kED_libXC%grid = xcpot%is_kED_schr%grid + 0.25 * xcpot%is_lapl%grid
         do i = 1,atoms%ntype
            mt_kED_libXC(i)%grid = xcpot%mt_kED_schr(i)%grid + 0.25 * xcpot%mt_lapl(i)%grid
         enddo

         call integrate_grid(xcpot, stars, atoms, sym, vacuum, input, cell, oneD, sphhar,noco,&
                             is_kED_libXC, mt_kED_libXC, &
                             q, qis, qmt, qvac, qtot, qistot)
         call print_qs(q,qis,qmt,qvac,qtot,qistot,"kED_libxc")
      endif

   END SUBROUTINE integrate_kED_libxc

   subroutine print_qs(q,qis,qmt,qvac,qtot,qistot, label)
      implicit none
      REAL, INTENT(in)             :: q(:), qis(:), qmt(:,:), qvac(:,:), qtot, qistot
      character(len=*), intent(in) :: label
         
      write (*,*) "------------------------"
      write (*,*) label // " integration:"
      write (*,*) "q = "
      write (*,'(ES17.10)') q
      write (*,*) "qis = "
      write (*,'(ES17.10)') qis
      write (*,*) "qmt = "
      write (*,'(ES17.10)') qmt

      if(.not. all(isnan(qvac))) then
         write (*,*) "qvac = "
         write (*,'(ES17.10)') qvac
      endif

      write (*,*) "qtot = "
      write (*,'(ES17.10)') qtot
      write (*,*) "qistot = "
      write (*,'(ES17.10)') qistot
      write (*,*) "------------------------"
   end subroutine print_qs
END MODULE m_vgen
